{"version":3,"sources":["sprintf.js"],"names":["re","notType","notPrimitive","number","numericArg","jsonObject","plainText","doublePercent","placeholder","namedKey","dotAccess","bracketAccess","numeralPrefix","allowedNamedKeyChars","allowedNumericIndex","allowComputedValue","throwErrorOnUnmatched","preserveUnmatchedPlaceholder","sprintfCache","let","cache","__proto__","get","key","set","value","this","has","delete","clear","sprintf","format","parseResult","_format","parseTree","namedUsed","positionalUsed","match","exec","push","SyntaxError","fieldList","replacementField","fieldMatch","test","substring","length","paramNo","keys","padChar","align","width","precision","type","result","sprintfFormat","argv","Array","prototype","slice","call","arguments","usesNamedArgs","cursor","treeLength","namedArgs","output","filteredArgv","idx","arg","Object","toString","target","TypeError","source","hasOwnProperty","pad","k","placeholderKey","Error","undefined","paramIndex","e","isNaN","isPositive","hex","parseInt","String","fromCharCode","Math","trunc","Number","JSON","stringify","parseFloat","toExponential","toFixed","toPrecision","toLowerCase","valueOf","high","padStart","highBits","BigInt","highHex","toUpperCase","replace","padCharacter","charAt","padLength","character","count","RangeError","vsprintf","apply","concat","sprintfLib","window","defineProperty","define","amd","exports","module"],"mappings":"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","file":"sprintf.min.js","sourcesContent":["/* global BigInt, window, exports, define */\n\n!function () {\n    'use strict';\n\n    /**\n     * Regular expressions used for parsing format strings\n     * @namespace\n     */\n    const re = {\n        // Matches if type is NOT 'T' (type detection)\n        notType: /[^T]/,\n        // Matches if type is NOT 'v' (primitive value)\n        notPrimitive: /[^v]/,\n        // Matches numeric format specifiers\n        number: /[diefg]/,\n        // Matches numeric argument types requiring number validation\n        numericArg: /[bcdiefguxX]/,\n        // Matches JSON object specifier\n        jsonObject: /[j]/,\n        // Matches plain text between format specifiers\n        plainText: /^[^\\x25]+/,\n        // Matches double percent (escaped percent)\n        doublePercent: /^\\x25{2}/,\n        // Matches format placeholder components\n        placeholder: /^\\x25(?:([1-9]\\d*)\\$|\\(([^)]+)\\))?(\\+)?(0|'[^$])?(-)?(\\d+)?(?:\\.(\\d+))?([b-gijostTuvxX])/,\n        // Matches valid named argument keys\n        namedKey: /^([a-z_][a-z_\\d]*)/i,\n        // Matches dot notation in named arguments\n        dotAccess: /^\\.([a-z_][a-z_\\d]*)/i,\n        // Matches array index access in named arguments\n        bracketAccess: /^\\[(\\d+)\\]/,\n        // Matches numeric sign prefixes\n        numeralPrefix: /^[+-]/,\n        allowedNamedKeyChars: /^[a-zA-Z_][a-zA-Z0-9_]*$/,\n        allowedNumericIndex: /^\\d+$/\n    };\n\n    let allowComputedValue = false;\n\n    let throwErrorOnUnmatched = false;\n\n    let preserveUnmatchedPlaceholder = false;\n\n    /**\n     * Cache for parsed format strings to improve performance\n     * @type {Map<string, {parseTree: Array<string|Placeholder>, namedUsed: boolean, positionalUsed: boolean}>}\n     */\n    const sprintfCache = createCache(); // Optimized version of new Map();\n\n    /**\n     * @typedef {Object} Placeholder\n     * @property {string} placeholder - The entire matched placeholder string\n     * @property {string} [paramNo] - Positional parameter number (1-based index)\n     * @property {Array<string>} [keys] - Named parameter access path\n     * @property {string} [numeralPrefix] - '+' sign for positive numbers\n     * @property {string} [padChar] - Padding character (e.g., '0' or space)\n     * @property {boolean} [align] - Left-align flag (true when '-' present)\n     * @property {string} [width] - Minimum field width\n     * @property {string} [precision] - Precision for numbers/strings\n     * @property {string} type - Conversion type character\n     */\n\n    /**\n     * Main formatting function similar to C's sprintf\n     * @param {string} format - Format string containing placeholders\n     * @param {...*} args - Values to format\n     * @returns {string} Formatted string\n     * @throws {Error} On invalid arguments or formatting errors\n     */\n    function sprintf(format) {\n        const parseResult = sprintfParse(format);\n        // Replaced Array.from(arguments).slice(1) in favor of Array.prototype.slice.call(arguments, 1)\n        return sprintfFormat(parseResult.parseTree, Array.prototype.slice.call(arguments, 1), parseResult.namedUsed);\n    }\n\n    /**\n     * Version of sprintf that accepts arguments as an array\n     * @param {string} format - Format string\n     * @param {Array} argv - Array of values to format\n     * @returns {string} Formatted string\n     */\n    function vsprintf(format, argv) {\n        return sprintf.apply(null, [format].concat(argv || []));\n    }\n\n    /**\n     * Core formatting engine that processes parsed format tree\n     * @param {Array<string|Placeholder>} parseTree - Result from sprintfParse()\n     * @param {Array} argv - Values to format\n     * @param {boolean} usesNamedArgs - Whether format uses named arguments\n     * @returns {string} Formatted string\n     * @throws {TypeError} On invalid numeric arguments\n     * @throws {Error} On missing named arguments\n     */\n    function sprintfFormat(parseTree, argv, usesNamedArgs) {\n        // Because of removing __proto__ parsetree can be undefined\n        if (typeof parseTree === 'undefined') return '';\n\n        const MAX_UINT32 = 0xFFFFFFFF;\n        const MAX_INT32 = 0x7FFFFFFF;\n        const MIN_INT32 = -0x80000000;\n\n        let cursor = 0;\n        const treeLength = parseTree.length;\n        const namedArgs = { __proto__: null };\n        let output = '';\n\n        // Extract named arguments and filter positional arguments if named are used\n        const filteredArgv = [];\n\n        if (usesNamedArgs) {\n            for (let idx = 0; idx < argv.length; idx++) {\n                const arg = argv[idx];\n\n                if (\n                    arg !== null &&\n                    typeof arg === 'object' &&\n                    Object.prototype.toString.call(arg) !== '[object Array]'\n                ) { // Replace Array.isArray in favor of Object.prototype.toString.call(arg) === '[object Array]'\n                    objectAssign(namedArgs, arg);\n                } else {\n                    filteredArgv.push(arg);\n                }\n            }\n\n            // Use filteredArgv for positional parameters\n            argv = filteredArgv;\n        }\n\n        for (let idx = 0; idx < treeLength; idx++) {\n            const placeholder = parseTree[idx];\n\n            if (typeof placeholder === 'string') {\n                output += placeholder;\n\n                continue;\n            }\n\n            let arg;\n\n            // Get the argument value\n            if (placeholder.keys) { // keyword argument\n                arg = namedArgs;\n\n                for (let k = 0; k < placeholder.keys.length; k++) {\n                    const placeholderKey = placeholder.keys[k];\n\n                    if (arg === undefined || arg === null) {\n                        throw new Error(`[sprintf] Cannot access property \"${placeholderKey}\" of undefined value`);\n                    }\n\n                    arg = arg[placeholderKey];\n\n                    if (throwErrorOnUnmatched && arg === undefined) {\n                        throw new SyntaxError(`[sprintf] Missing argument ${placeholderKey}`);\n                    }\n\n                    if (preserveUnmatchedPlaceholder && arg === undefined) {\n                        arg = placeholder.placeholder;\n                    }\n                }\n\n            } else if (placeholder.paramNo) { // Explicit positional argument\n                const paramIndex = placeholder.paramNo - 1;\n\n                if (throwErrorOnUnmatched && paramIndex >= argv.length) {\n                    throw new SyntaxError(`[sprintf] Missing argument ${placeholder.paramNo}`);\n                }\n\n                arg = argv[paramIndex];\n\n                if (preserveUnmatchedPlaceholder && arg === undefined) {\n                    arg = placeholder.placeholder;\n                }\n            } else { // Implicit positional argument\n                if (throwErrorOnUnmatched && cursor >= argv.length) {\n                    throw new SyntaxError('[sprintf] Too few arguments');\n                }\n\n                arg = argv[cursor++];\n\n                if (preserveUnmatchedPlaceholder && arg === undefined) {\n                    arg = placeholder.placeholder;\n                }\n            }\n\n            // Handle function arguments for non-type/non-primitive specifiers\n            if (typeof allowComputedValue === 'boolean' && allowComputedValue) {\n                if (re.notType.test(placeholder.type) && re.notPrimitive.test(placeholder.type) && typeof arg === 'function') {\n                    try {\n                        arg = arg();\n                    } catch (e) {\n                        throw new Error('[sprintf] Failed to execute function argument');\n                    }\n                }\n            }\n\n            // Validate numeric arguments for numeric placeholders\n            if (re.numericArg.test(placeholder.type) && (typeof arg !== 'number' && isNaN(arg))) {\n                throw new TypeError(`[sprintf] expecting number but found ${typeof arg}`);\n            }\n\n            let isPositive;\n\n            let numeralPrefix = '';\n\n            let hex;\n\n            // Format according to type\n            if (re.number.test(placeholder.type)) {\n                isPositive = arg >= 0;\n            }\n\n            // Process argument based on format specifier\n            switch (placeholder.type) {\n                case 'b': // Binary\n                    arg = parseInt(arg, 10).toString(2);\n                    break;\n                case 'c': // Character\n                    arg = String.fromCharCode(parseInt(arg, 10));\n                    break;\n                case 'd': // Integer\n                case 'i':\n                    arg = Math.trunc(Number(arg));\n                    break;\n                case 'j': // JSON\n                    arg = JSON.stringify(arg, null, placeholder.width ? parseInt(placeholder.width) : 0);\n                    break;\n                case 'e': // Exponential notation\n                    arg = placeholder.precision ? parseFloat(arg).toExponential(placeholder.precision) : parseFloat(arg).toExponential();\n                    break;\n                case 'f': // Fixed-point\n                    arg = placeholder.precision ? parseFloat(arg).toFixed(placeholder.precision) : parseFloat(arg);\n                    break;\n                case 'g': // General format\n                    arg = placeholder.precision ? String(arg.toPrecision(placeholder.precision)) : parseFloat(arg);\n                    break;\n                case 'o': // Octal\n                    arg = (parseInt(arg, 10) >>> 0).toString(8);\n                    break;\n                case 's': // String\n                    arg = String(arg);\n\n                    arg = (placeholder.precision ? arg.substring(0, placeholder.precision) : arg);\n                    break;\n                case 't': // Boolean\n                    arg = String(!!arg);\n\n                    arg = (placeholder.precision ? arg.substring(0, placeholder.precision) : arg);\n                    break;\n                case 'T': // Type detection\n                    arg = Object.prototype.toString.call(arg).slice(8, -1).toLowerCase();\n\n                    arg = (placeholder.precision ? arg.substring(0, placeholder.precision) : arg);\n                    break;\n                case 'u': // Unsigned integer\n                    arg = parseInt(arg, 10) >>> 0;\n                    break;\n                case 'v': // Primitive value\n                    arg = String(arg.valueOf());\n\n                    arg = (placeholder.precision ? arg.substring(0, placeholder.precision) : arg);\n                    break;\n                case 'x':\n                case 'X':\n                    hex = (parseInt(arg, 10) >>> 0).toString(16);\n\n                    if (arg && arg.high) {\n                        // Handle special objects with 'high' property (likely for 64-bit integers)\n                        hex = (parseInt(arg.high, 10) >>> 0).toString(16) + hex.padStart(8, '0');\n                    } else if (Number(arg) > MAX_INT32 || Number(arg) < MIN_INT32) {\n                        // Handle values outside 32-bit signed integer range using BigInt\n                        try {\n                            // Use BigInt for large number handling\n                            const bigIntValue = BigInt(arg);\n                            const highBits = bigIntValue >> BigInt(32);\n                            const highHex = (highBits & BigInt(MAX_UINT32)).toString(16);\n\n                            hex = highBits !== BigInt(0) ? highHex + hex.padStart(8, '0') : hex;\n                        } catch (e) {\n                            // Fallback if BigInt fails (e.g., on older browsers), keep the original hex value\n                        }\n                    }\n\n                    arg = placeholder.type === 'X' ? hex.toUpperCase() : hex;\n                    break;\n                default:\n                    throw new Error(`[sprintf] Unknown type: ${placeholder.type}`);\n            }\n\n            // Apply padding and alignment\n            if (re.jsonObject.test(placeholder.type)) {\n                output += arg;\n            } else {\n                // Handle numeric sign prefix\n                if (re.number.test(placeholder.type) && (!isPositive || placeholder.numeralPrefix)) {\n                    numeralPrefix = isPositive ? '+' : '-';\n\n                    arg = String(arg).replace(re.numeralPrefix, '');\n                } else {\n                    numeralPrefix = '';\n                }\n\n                const padCharacter = placeholder.padChar ? placeholder.padChar === '0' ? '0' : placeholder.padChar.charAt(1) : ' ';\n\n                const padLength = placeholder.width - (numeralPrefix + arg).length;\n\n                const pad = placeholder.width && padLength > 0 ? stringRepeat(padCharacter, padLength) : ''; // padCharacter.repeat(padLength) replaced in favor of custom function\n\n                output += placeholder.align ? numeralPrefix + arg + pad : (padCharacter === '0' ? numeralPrefix + pad + arg : pad + numeralPrefix + arg);\n            }\n        }\n\n        return output;\n    }\n\n    /**\n     * Parses format string into executable tree structure\n     * @param {string} format - Format string to parse\n     * @returns {{parseTree: Array<string|Placeholder>, namedUsed: boolean, positionalUsed: boolean}}\n     * @throws {SyntaxError} On invalid format syntax\n     */\n    function sprintfParse(format) {\n        if (sprintfCache.has(format)) {\n            return sprintfCache.get(format);\n        }\n\n        let _format = format;\n        const parseTree = [];\n        let namedUsed = false;\n        let positionalUsed = false;\n\n        while (_format) {\n            let match;\n\n            // Match plain text between placeholders\n            if ((match = re.plainText.exec(_format)) !== null) {\n                parseTree.push(match[0]);\n            }\n            // Match escaped percent (%%)\n            else if ((match = re.doublePercent.exec(_format)) !== null) {\n                parseTree.push('%');\n            }\n            // Match complex placeholders\n            else if ((match = re.placeholder.exec(_format)) !== null) {\n                // Handle named arguments\n                if (match[2]) {\n                    namedUsed = true;\n                    const fieldList = [];\n                    let replacementField = match[2];\n                    let fieldMatch;\n\n                    if ((fieldMatch = re.namedKey.exec(replacementField)) !== null) {\n                        if (!re.allowedNamedKeyChars.test(fieldMatch[1])) {\n                            throw new SyntaxError('[sprintf] Invalid named argument key segment: must start with a letter or underscore, followed by letters, numbers, or underscores');\n                        }\n\n                        fieldList.push(fieldMatch[1]);\n\n                        while ((replacementField = replacementField.substring(fieldMatch[0].length)) !== '') {\n                            if ((fieldMatch = re.dotAccess.exec(replacementField)) !== null) {\n                                if (!re.allowedNamedKeyChars.test(fieldMatch[1])) {\n                                    throw new SyntaxError('[sprintf] Invalid named argument key segment after dot: must start with a letter or underscore, followed by letters, numbers, or underscores');\n                                }\n\n                                fieldList.push(fieldMatch[1]);\n                            } else if ((fieldMatch = re.bracketAccess.exec(replacementField)) !== null) {\n                                if (!re.allowedNumericIndex.test(fieldMatch[1])) { // Ensure index is a number\n                                    throw new SyntaxError('[sprintf] Invalid array index in named argument key: must be a non-negative integer');\n                                }\n\n                                fieldList.push(fieldMatch[1]);\n                            } else {\n                                throw new SyntaxError('[sprintf] failed to parse named argument key');\n                            }\n                        }\n                    }\n                    else {\n                        throw new SyntaxError('[sprintf] failed to parse named argument key');\n                    }\n\n                    match[2] = fieldList;\n                }\n                // Handle positional arguments\n                else if (match[1]) { // Explicit positional placeholder\n                    positionalUsed = true;\n                }\n                else { // Implicit positional placeholder\n                    positionalUsed = true;\n                }\n\n                parseTree.push({\n                    placeholder: match[0],\n                    paramNo: match[1],\n                    keys: match[2],\n                    numeralPrefix: match[3],\n                    padChar: match[4],\n                    align: match[5],\n                    width: match[6],\n                    precision: match[7],\n                    type: match[8]\n                });\n            }\n            else {\n                throw new SyntaxError('[sprintf] unexpected placeholder');\n            }\n\n            _format = _format.substring(match[0].length);\n        }\n\n        const result = {\n            parseTree,\n            namedUsed,\n            positionalUsed\n        };\n\n        sprintfCache.set(format, result);\n\n        return result;\n    }\n\n    /**\n     * Copies the values of all of the enumerable own properties from one or\n     * more source objects to a target object. It will return the target object.\n     * @param {object} target The target object to apply the sources' properties to.\n     * @param {...object} sources The source object(s) from which to copy properties.\n     * @returns {object} The target object.\n     * @throws {TypeError} If target is null or undefined.\n     * @throws {TypeError} If no arguments are provided.\n     */\n    function objectAssign(target) {\n        if (arguments.length < 1) {\n            throw new TypeError('objectAssign expects at least one argument');\n        }\n\n        if (target === null || target === undefined) {\n            throw new TypeError('Cannot convert undefined or null to object');\n        }\n\n        for (let idx = 1; idx < arguments.length; idx++) {\n            const source = arguments[idx];\n\n            if (source === null || source === undefined) {\n                continue;\n            }\n\n            for (const key in source) {\n                if (Object.prototype.hasOwnProperty.call(source, key)) { // Only copy properties that are directly on the source object (not inherited)\n                    target[key] = source[key];\n                }\n            }\n        }\n\n        return target;\n    }\n\n    /**\n     * Constructs and returns a new string which contains the specified number\n     * of copies of the string on which it was called, concatenated together.\n     * @param {string} character The string to be repeated.\n     * @param {number} count An integer indicating the number of times to repeat the string.\n     * @returns {string} A new string containing the specified number of copies of the given character.\n     * @throws {RangeError} If count is negative.\n     */\n    function stringRepeat(character, count) {\n        if (count < 0) {\n            throw new RangeError('Repeat count must be non-negative');\n        }\n\n        if (count === 0) {\n            return '';\n        }\n\n        let result = '';\n\n        while (count) {\n            if (count & 1) { // Bitwise operations to handle count\n                result += character;\n            }\n\n            count >>= 1; // Bitwise right shift (equivalent to count = Math.floor(count / 2))\n\n            character += character;\n        }\n\n        return result;\n    }\n\n    /**\n     * Creates and returns a simple cache object.\n     * @returns {object} An object with methods for managing a cache.\n     */\n    function createCache() {\n        let cache = { __proto__: null };\n\n        return {\n            /**\n             * Retrieves a value from the cache.\n             * @param {string} key The key of the value to retrieve.\n             * @returns {*} The value associated with the key, or undefined if not found.\n             */\n            get: function (key) {\n                return cache[key];\n            },\n            /**\n             * Stores a value in the cache.\n             * @param {string} key The key to store the value under.\n             * @param {*} value The value to store.\n             * @returns {this} The cache object for chaining.\n             */\n            set: function (key, value) {\n                cache[key] = value;\n\n                return this;\n            },\n            /**\n             * Checks if a key exists in the cache.\n             * @param {string} key The key to check for.\n             * @returns {boolean} True if the key exists in the cache, false otherwise.\n             */\n            has: function (key) {\n                return key in cache;\n            },\n            /**\n             * Removes a key and its associated value from the cache.\n             * @param {string} key The key to remove.\n             */\n            delete: function (key) {\n                delete cache[key];\n            },\n            /**\n             * Clears all entries from the cache.\n             */\n            clear: function () {\n                cache = { __proto__: null };\n            }\n        };\n    }\n\n    // Module export setup\n    const sprintfLib = {\n        get allowComputedValue() { return allowComputedValue; },\n        set allowComputedValue(value) { allowComputedValue = value; },\n        get preserveUnmatchedPlaceholder() { return preserveUnmatchedPlaceholder; },\n        set preserveUnmatchedPlaceholder(value) { preserveUnmatchedPlaceholder = value; },\n        get throwErrorOnUnmatched() { return throwErrorOnUnmatched; },\n        set throwErrorOnUnmatched(value) { throwErrorOnUnmatched = value; },\n        sprintf: sprintf,\n        vsprintf: vsprintf\n    };\n\n    // Browser global export\n    if (typeof window !== 'undefined') {\n        window.sprintf = sprintf;\n        window.vsprintf = vsprintf;\n\n        Object.defineProperty(window.sprintf, 'allowComputedValue', {\n            get: () => allowComputedValue,\n            set: (value) => { allowComputedValue = value; }\n        });\n\n        Object.defineProperty(window.sprintf, 'preserveUnmatchedPlaceholder', {\n            get: () => preserveUnmatchedPlaceholder,\n            set: (value) => { preserveUnmatchedPlaceholder = value; }\n        });\n\n        Object.defineProperty(window.sprintf, 'throwErrorOnUnmatched', {\n            get: () => throwErrorOnUnmatched,\n            set: (value) => { throwErrorOnUnmatched = value; }\n        });\n\n        // AMD module definition\n        if (typeof define === 'function' && define.amd) {\n            define(() => sprintfLib);\n        }\n    }\n\n    // CommonJS export\n    if (typeof exports !== 'undefined') {\n        exports.sprintf = sprintf;\n        exports.vsprintf = vsprintf;\n\n        Object.defineProperty(exports.sprintf, 'allowComputedValue', {\n            get: () => allowComputedValue,\n            set: (value) => { allowComputedValue = value; }\n        });\n\n        Object.defineProperty(exports.sprintf, 'preserveUnmatchedPlaceholder', {\n            get: () => preserveUnmatchedPlaceholder,\n            set: (value) => { preserveUnmatchedPlaceholder = value; }\n        });\n\n        Object.defineProperty(exports.sprintf, 'throwErrorOnUnmatched', {\n            get: () => throwErrorOnUnmatched,\n            set: (value) => { throwErrorOnUnmatched = value; }\n        });\n    }\n\n    // Node.js module export\n    if (typeof module !== 'undefined' && module.exports) {\n        module.exports = sprintfLib;\n    }\n}();\n"]}