{"version":3,"sources":["sprintf.js"],"names":["re","notType","notPrimitive","number","numericArg","jsonObject","plainText","doublePercent","placeholder","namedKey","dotAccess","bracketAccess","numeralPrefix","allowedNamedKeyChars","allowedNumericIndex","defaultOptions","allowComputedValue","throwErrorOnUnmatched","preserveUnmatchedPlaceholder","sprintfCache","let","cache","__proto__","get","key","set","value","this","has","delete","clear","sprintf","format","options","_sprintfOptions","stats","_sprintfStats","parseResult","sprintfParse","sprintfFormat","parseTree","Array","prototype","slice","call","arguments","namedUsed","vsprintf","argv","fmt","apply","concat","config","newOptions","objectAssign","chainableConfig","totalPlaceholders","totalNamedPlaceholder","totalPositionalPlaceholder","totalSequentialPositionalPlaceholder","getStats","usesNamedArgs","cursor","treeLength","length","namedArgs","output","filteredArgv","idx","arg","Object","toString","push","keys","k","placeholderKey","Error","undefined","SyntaxError","paramNo","paramIndex","precisionValue","padCharacter","pad","isFunctionArg","test","type","e","isNaN","TypeError","isPositive","tmp","parseInt","String","fromCharCode","Math","trunc","Number","JSON","stringify","width","precision","parts","parseFloat","toExponential","split","mantissa","expVal","expSign","expDigits","abs","padStart","error","toUpperCase","toFixed","toPrecision","substring","toLowerCase","valueOf","high","highBits","BigInt","highHex","replace","padChar","charAt","padLength","character","count","RangeError","result","align","_format","positionalUsed","match","exec","fieldList","replacementField","fieldMatch","target","source","hasOwnProperty","sprintfLib","window","define","amd","exports","module"],"mappings":"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","file":"sprintf.min.js","sourcesContent":["/* global BigInt, window, exports, define */\n\n!function () {\n    'use strict';\n\n    /**\n     * Regular expressions used for parsing format strings\n     * @namespace\n     */\n    const re = {\n        // Matches if type is NOT 'T' (type detection)\n        notType: /[^T]/,\n        // Matches if type is NOT 'v' (primitive value)\n        notPrimitive: /[^v]/,\n        // Matches numeric format specifiers\n        number: /[dieEfg]/,\n        // Matches numeric argument types requiring number validation\n        numericArg: /[bcdieEfguxX]/,\n        // Matches JSON object specifier\n        jsonObject: /[j]/,\n        // Matches plain text between format specifiers\n        plainText: /^[^\\x25]+/,\n        // Matches double percent (escaped percent)\n        doublePercent: /^\\x25{2}/,\n        // Matches format placeholder components\n        placeholder: /^\\x25(?:([1-9]\\d*)\\$|\\(([^)]+)\\))?(\\+)?(0|'[^$])?(-)?(\\d+)?(?:\\.(\\d*))?([bcdieEfgjostTuvxX])/,\n        // Matches valid named argument keys\n        namedKey: /^([a-z_][a-z_\\d]*)/i,\n        // Matches dot notation in named arguments\n        dotAccess: /^\\.([a-z_][a-z_\\d]*)/i,\n        // Matches array index access in named arguments\n        bracketAccess: /^\\[(\\d+)\\]/,\n        // Matches numeric sign prefixes\n        numeralPrefix: /^[+-]/,\n        allowedNamedKeyChars: /^[a-zA-Z_][a-zA-Z0-9_]*$/,\n        allowedNumericIndex: /^\\d+$/\n    };\n\n    /**\n     * Default configuration options for the sprintf function.\n     * @type {SprintfOptions}\n     */\n    const defaultOptions = {\n        allowComputedValue: false,\n        throwErrorOnUnmatched: false,\n        preserveUnmatchedPlaceholder: false,\n    };\n\n    /**\n     * @typedef {Object} SprintfOptions\n     * @property {boolean} allowComputedValue - If true, when an argument passed to sprintf is a function, it will be executed, and its return value will be used as the value for the corresponding placeholder. Defaults to false.\n     * @property {boolean} throwErrorOnUnmatched - If true, throws a SyntaxError when a placeholder in the format string does not have a corresponding argument. Defaults to false.\n     * @property {boolean} preserveUnmatchedPlaceholder - If true, unmatched placeholders in the format string will be preserved in the output. Defaults to false.\n     */\n\n    /**\n     * Cache for parsed format strings to improve performance.\n     * This variable holds an object with methods to manage the cache of parsed format strings.\n     */\n    const sprintfCache = createCache(); // Optimized version of new Map();\n\n    /**\n     * @typedef {Object} ParseTree\n     * @property {string} placeholder - The entire matched placeholder string\n     * @property {string | undefined} [paramNo] - Positional parameter number (1-based index)\n     * @property {Array<string> | undefined} [keys] - Named parameter access path\n     * @property {string | undefined} [numeralPrefix] - '+' sign for positive numbers\n     * @property {string | undefined} [padChar] - Padding character (e.g., '0' or space)\n     * @property {boolean | undefined} [align] - Left-align flag (true when '-' present)\n     * @property {string | undefined} [width] - Minimum field width\n     * @property {string | undefined} [precision] - Precision for numbers/strings\n     * @property {string} type - Conversion type character\n     */\n\n    /**\n     * @typedef {Object} SprintfParseResult\n     * @property {Array<ParseTree>} parseTree - The parsed format string represented as an array of ParseTree objects.\n     * @property {boolean} namedUsed - Indicates whether named arguments were used in the format string.\n     * @property {boolean} positionalUsed - Indicates whether positional arguments were used in the format string.\n     */\n\n    /**\n     * Main formatting function similar to C's sprintf\n     * @param {string} format - Format string containing placeholders\n     * @param {...*} args - Values to format\n     * @returns {string} Formatted string\n     * @throws {Error} On invalid arguments or formatting errors\n     */\n    function sprintf(format) {\n        const options = this && this._sprintfOptions ? this._sprintfOptions : defaultOptions;\n        const stats = this && this._sprintfStats ? this._sprintfStats : { __proto__: null };\n\n        const parseResult = sprintfParse(format);\n\n        // Extract args and format using current options\n        return sprintfFormat(parseResult.parseTree, Array.prototype.slice.call(arguments, 1), parseResult.namedUsed, options, stats);\n    }\n\n    /**\n     * Version of sprintf that accepts arguments as an array\n     * @param {string} format - Format string\n     * @param {Array} argv - Array of values to format\n     * @returns {string} Formatted string\n     */\n    function vsprintf(format, argv) {\n        const options = this && this._sprintfOptions ? this._sprintfOptions : defaultOptions;\n        const stats = this && this._sprintfStats ? this._sprintfStats : { __proto__: null };\n\n        // Create a temporary function with the current options\n        const tempSprintf = function (fmt) {\n            return sprintfFormat(sprintfParse(fmt).parseTree, Array.prototype.slice.call(arguments, 1), sprintfParse(fmt).namedUsed, options, stats);\n        };\n\n        return tempSprintf.apply(null, [format].concat(argv || []));\n    }\n\n    /**\n     * Creates a chainable configuration object for sprintf\n     * @param {Object} options - Configuration options\n     * @returns {Object} A chainable configuration object\n     */\n    function config(options) {\n        // Create a fresh configuration object by cloning defaultOptions\n        const newOptions = objectAssign({ __proto__: null }, defaultOptions);\n\n        // Apply passed options if any\n        if (options) {\n            if (typeof options.allowComputedValue === 'boolean') {\n                newOptions.allowComputedValue = options.allowComputedValue;\n            }\n            if (typeof options.throwErrorOnUnmatched === 'boolean') {\n                newOptions.throwErrorOnUnmatched = options.throwErrorOnUnmatched;\n            }\n            if (typeof options.preserveUnmatchedPlaceholder === 'boolean') {\n                newOptions.preserveUnmatchedPlaceholder = options.preserveUnmatchedPlaceholder;\n            }\n        }\n\n        // Create a chainable configuration object\n        const chainableConfig = {\n            _sprintfOptions: newOptions,\n            _sprintfStats: {\n                totalPlaceholders: 0,\n                totalNamedPlaceholder: 0,\n                totalPositionalPlaceholder: 0,\n                totalSequentialPositionalPlaceholder: 0\n            },\n\n            // Method to format with current config\n            sprintf: sprintf,\n            vsprintf: vsprintf,\n\n            getStats: function () {\n                return this._sprintfStats;\n            },\n\n            // Methods to modify configuration\n            allowComputedValue: function (value) {\n                this._sprintfOptions.allowComputedValue = !!value;\n                return this;\n            },\n\n            throwErrorOnUnmatched: function (value) {\n                this._sprintfOptions.throwErrorOnUnmatched = !!value;\n                return this;\n            },\n\n            preserveUnmatchedPlaceholder: function (value) {\n                this._sprintfOptions.preserveUnmatchedPlaceholder = !!value;\n                return this;\n            }\n        };\n\n        return chainableConfig;\n    }\n\n    /**\n     * Core formatting engine that processes parsed format tree.\n     * @param {Array<ParseTree>} parseTree - Result from sprintfParse().\n     * @param {Array} argv - Values to format.\n     * @param {boolean} usesNamedArgs - Whether the format string uses named arguments.\n     * @param {Object} options - Configuration options.\n     * @param {Object} stats - An object to collect statistics about the formatting process.\n     * @returns {string} Formatted string.\n     * @throws {TypeError} On invalid numeric arguments.\n     * @throws {Error} When accessing a property of an undefined named argument or if a function argument execution fails.\n     * @throws {SyntaxError} On missing named or positional arguments when `options.throwErrorOnUnmatched` is true, or if there are too few positional arguments for implicit placeholders.\n     */\n    function sprintfFormat(parseTree, argv, usesNamedArgs, options, stats) {\n        // Because of removing __proto__ parsetree can be undefined\n        if (typeof parseTree === 'undefined') return '';\n\n        const MAX_UINT32 = 0xFFFFFFFF;\n        const MAX_INT32 = 0x7FFFFFFF;\n        const MIN_INT32 = -0x80000000;\n\n        let cursor = 0;\n        const treeLength = parseTree.length;\n        const namedArgs = { __proto__: null };\n        let output = '';\n\n        // Extract named arguments and filter positional arguments if named are used\n        const filteredArgv = [];\n\n        if (usesNamedArgs) {\n            for (let idx = 0; idx < argv.length; idx++) {\n                const arg = argv[idx];\n\n                if (\n                    arg !== null &&\n                    typeof arg === 'object' &&\n                    Object.prototype.toString.call(arg) !== '[object Array]'\n                ) { // Replace Array.isArray in favor of Object.prototype.toString.call(arg) === '[object Array]'\n                    objectAssign(namedArgs, arg);\n                } else {\n                    filteredArgv.push(arg);\n                }\n            }\n\n            // Use filteredArgv for positional parameters\n            argv = filteredArgv;\n        }\n\n        for (let idx = 0; idx < treeLength; idx++) {\n            const placeholder = parseTree[idx];\n\n            if (typeof placeholder === 'string') {\n                output += placeholder;\n\n                continue;\n            }\n\n            let arg;\n\n            stats.totalPlaceholders++;\n\n            // Get the argument value\n            if (placeholder.keys) { // keyword argument\n                arg = namedArgs;\n\n                for (let k = 0; k < placeholder.keys.length; k++) {\n                    const placeholderKey = placeholder.keys[k];\n\n                    if (arg === undefined || arg === null) {\n                        throw new Error(`[sprintf] Cannot access property \"${placeholderKey}\" of undefined value`);\n                    }\n\n                    arg = arg[placeholderKey];\n\n                    if (options.throwErrorOnUnmatched && arg === undefined) {\n                        throw new SyntaxError(`[sprintf] Missing argument ${placeholderKey}`);\n                    }\n\n                    if (options.preserveUnmatchedPlaceholder && arg === undefined) {\n                        arg = placeholder.placeholder;\n                    }\n\n                    stats.totalNamedPlaceholder++;\n                }\n\n            } else if (placeholder.paramNo) { // Explicit positional argument\n                const paramIndex = placeholder.paramNo - 1;\n\n                if (options.throwErrorOnUnmatched && paramIndex >= argv.length) {\n                    throw new SyntaxError(`[sprintf] Missing argument ${placeholder.paramNo}`);\n                }\n\n                arg = argv[paramIndex];\n\n                if (options.preserveUnmatchedPlaceholder && arg === undefined) {\n                    arg = placeholder.placeholder;\n                }\n\n                stats.totalPositionalPlaceholder++;\n            } else { // Implicit positional argument\n                if (options.throwErrorOnUnmatched && cursor >= argv.length) {\n                    throw new SyntaxError('[sprintf] Too few arguments');\n                }\n\n                arg = argv[cursor++];\n\n                if (options.preserveUnmatchedPlaceholder && arg === undefined) {\n                    arg = placeholder.placeholder;\n                }\n\n                stats.totalSequentialPositionalPlaceholder++;\n            }\n\n            // Handle function arguments for non-type/non-primitive specifiers\n            const isFunctionArg = re.notType.test(placeholder.type) && re.notPrimitive.test(placeholder.type) &&\n                (typeof arg === 'function' || Object.prototype.toString.call(arg) === '[object Function]');\n\n\n            if (!options.allowComputedValue && isFunctionArg) {\n                throw new Error('[sprintf] Function arguments are not allowed by default. Enable with .config().allowComputedValue(true)');\n            }\n\n            if (options.allowComputedValue && isFunctionArg) {\n                try {\n                    arg = arg.apply(this);\n                } catch (e) {\n                    throw new Error('[sprintf] Failed to execute function argument');\n                }\n            }\n\n            // Validate numeric arguments for numeric placeholders\n            if (re.numericArg.test(placeholder.type)) {\n                // Check if arg is a number, BigInt, or can be converted to a number\n                if (typeof arg !== 'number' && typeof arg !== 'bigint' && isNaN(arg)) { // eslint-disable-line valid-typeof\n                    throw new TypeError(`[sprintf] expecting number or BigInt but found ${typeof arg}`);\n                }\n            }\n\n            let isPositive;\n\n            let numeralPrefix = '';\n\n            let tmp;\n\n            // Format according to type\n            if (re.number.test(placeholder.type)) {\n                isPositive = arg >= 0;\n            }\n\n            // Process argument based on format specifier\n            switch (placeholder.type) {\n                case 'b': // Binary\n                    tmp = parseInt(arg, 10);\n                    tmp = isNaN(tmp) ? 0 : tmp;\n                    // Truncate to 32 bits and handle two's complement\n                    tmp = tmp >>> 0; // Unsigned 32-bit conversion\n                    arg = tmp.toString(2);\n                    break;\n                case 'c': // Character\n                    tmp = parseInt(arg, 10);\n                    tmp = isNaN(tmp) ? 0 : tmp; // Handle non-integer to 0\n                    tmp = tmp & 0xFF;            // Clamp to 0-255 (like C's unsigned char)\n                    arg = String.fromCharCode(tmp);\n                    break;\n                case 'd': // Integer\n                case 'i':\n                    arg = typeof arg === 'bigint' ? arg.toString() : Math.trunc(Number(arg)); // eslint-disable-line valid-typeof\n                    break;\n                case 'j': // JSON\n                    arg = JSON.stringify(arg, null, placeholder.width ? parseInt(placeholder.width) : 0);\n                    break;\n                case 'e': // Exponential notation\n                case 'E':\n                    try {\n                        // Get precision (default to 6 if not specified)\n                        let precision = 6;\n\n                        if (placeholder.precision !== undefined) {\n                            precision = parseInt(placeholder.precision, 10) || 0;\n                        }\n\n                        const floatVal = parseFloat(arg);\n                        const formattedValue = floatVal.toExponential(precision);\n\n                        // Split into mantissa and exponent\n                        const parts = formattedValue.split('e');\n                        let mantissa = parts[0];\n                        const expVal = parseInt(parts[1], 10);\n\n                        // Handle precision=0 (strip decimal point)\n                        if (precision === 0) {\n                            mantissa = mantissa.split('.')[0];\n                        }\n\n                        // Format exponent to +00/-00 style (C compatibility)\n                        const expSign = expVal >= 0 ? '+' : '-';\n                        const expAbs = Math.abs(expVal);\n                        const expDigits = expAbs.toString().padStart(2, '0'); // Force 2 digits\n\n                        arg = `${mantissa}e${expSign}${expDigits}`;\n                    } catch (error) {\n                        arg = (placeholder.precision === 0) ? '0e+00' : '0.000000e+00';\n                    }\n\n                    if (placeholder.type === 'E') {\n                        arg = arg.toUpperCase();\n                    }\n                    break;\n                case 'f': // Fixed-point\n                    if (placeholder.precision !== undefined) {\n                        // If precision is an empty string (from .f), use precision 0\n                        const precisionValue = placeholder.precision === '' ? 0 : parseInt(placeholder.precision, 10);\n\n                        arg = parseFloat(arg).toFixed(precisionValue);\n                    } else {\n                        arg = parseFloat(arg);\n                    }\n                    break;\n                case 'g': // General format\n                    arg = placeholder.precision ? String(arg.toPrecision(placeholder.precision)) : parseFloat(arg);\n                    break;\n                case 'o': // Octal\n                    arg = (parseInt(arg, 10) >>> 0).toString(8);\n                    break;\n                case 's': // String\n                    arg = String(arg);\n\n                    arg = (placeholder.precision ? arg.substring(0, placeholder.precision) : arg);\n                    break;\n                case 't': // Boolean\n                    arg = String(!!arg);\n\n                    arg = (placeholder.precision ? arg.substring(0, placeholder.precision) : arg);\n                    break;\n                case 'T': // Type detection\n                    arg = Object.prototype.toString.call(arg).slice(8, -1).toLowerCase();\n\n                    arg = (placeholder.precision ? arg.substring(0, placeholder.precision) : arg);\n                    break;\n                case 'u': // Unsigned integer\n                    arg = parseInt(arg, 10) >>> 0;\n                    break;\n                case 'v': // Primitive value\n                    arg = String(arg.valueOf());\n\n                    arg = (placeholder.precision ? arg.substring(0, placeholder.precision) : arg);\n                    break;\n                case 'x':\n                case 'X':\n                    tmp = (parseInt(arg, 10) >>> 0).toString(16);\n\n                    if (arg && arg.high) {\n                        // Handle special objects with 'high' property (likely for 64-bit integers)\n                        tmp = (parseInt(arg.high, 10) >>> 0).toString(16) + tmp.padStart(8, '0');\n                    } else if (Number(arg) > MAX_INT32 || Number(arg) < MIN_INT32) {\n                        // Handle values outside 32-bit signed integer range using BigInt\n                        try {\n                            // Use BigInt for large number handling\n                            const bigIntValue = BigInt(arg);\n                            const highBits = bigIntValue >> BigInt(32);\n                            const highHex = (highBits & BigInt(MAX_UINT32)).toString(16);\n\n                            tmp = highBits !== BigInt(0) ? highHex + tmp.padStart(8, '0') : tmp;\n                        } catch (e) {\n                            // Fallback if BigInt fails (e.g., on older browsers), keep the original hex value\n                        }\n                    }\n\n                    arg = placeholder.type === 'X' ? tmp.toUpperCase() : tmp;\n                    break;\n                default:\n                    throw new Error(`[sprintf] Unknown type: ${placeholder.type}`);\n            }\n\n            // Apply padding and alignment\n            if (re.jsonObject.test(placeholder.type)) {\n                output += arg;\n            } else {\n                // Handle numeric sign prefix\n                if (re.number.test(placeholder.type) && (!isPositive || placeholder.numeralPrefix)) {\n                    numeralPrefix = isPositive ? '+' : '-';\n\n                    arg = String(arg).replace(re.numeralPrefix, '');\n                } else {\n                    numeralPrefix = '';\n                }\n\n                const padCharacter = placeholder.padChar ? placeholder.padChar === '0' ? '0' : placeholder.padChar.charAt(1) : ' ';\n\n                const padLength = placeholder.width - (numeralPrefix + arg).length;\n\n                const pad = placeholder.width && padLength > 0 ? stringRepeat(padCharacter, padLength) : ''; // padCharacter.repeat(padLength) replaced in favor of custom function\n\n                output += placeholder.align ? numeralPrefix + arg + pad : (padCharacter === '0' ? numeralPrefix + pad + arg : pad + numeralPrefix + arg);\n            }\n        }\n\n        return output;\n    }\n\n    /**\n     * Parses a format string into an executable tree structure.\n     * @param {string} format - The format string to parse, following sprintf syntax.\n     * @returns {SprintfParseResult} An object containing the parse tree and usage flags.\n     * @throws {SyntaxError} On invalid format syntax, including:\n     * - Invalid characters or structure in named argument keys.\n     * - Invalid array index format within named arguments.\n     * - Unexpected or unparseable placeholders.\n     */\n    function sprintfParse(format) {\n        if (sprintfCache.has(format)) {\n            return sprintfCache.get(format);\n        }\n\n        let _format = format;\n        const parseTree = [];\n        let namedUsed = false;\n        let positionalUsed = false;\n\n        while (_format) {\n            let match;\n\n            // Match plain text between placeholders\n            if ((match = re.plainText.exec(_format)) !== null) {\n                parseTree.push(match[0]);\n            }\n            // Match escaped percent (%%)\n            else if ((match = re.doublePercent.exec(_format)) !== null) {\n                parseTree.push('%');\n            }\n            // Match complex placeholders\n            else if ((match = re.placeholder.exec(_format)) !== null) {\n                // Handle named arguments\n                if (match[2]) {\n                    namedUsed = true;\n                    const fieldList = [];\n                    let replacementField = match[2];\n                    let fieldMatch;\n\n                    if ((fieldMatch = re.namedKey.exec(replacementField)) !== null) {\n                        if (!re.allowedNamedKeyChars.test(fieldMatch[1])) {\n                            throw new SyntaxError('[sprintf] Invalid named argument key segment: must start with a letter or underscore, followed by letters, numbers, or underscores');\n                        }\n\n                        fieldList.push(fieldMatch[1]);\n\n                        while ((replacementField = replacementField.substring(fieldMatch[0].length)) !== '') {\n                            if ((fieldMatch = re.dotAccess.exec(replacementField)) !== null) {\n                                if (!re.allowedNamedKeyChars.test(fieldMatch[1])) {\n                                    throw new SyntaxError('[sprintf] Invalid named argument key segment after dot: must start with a letter or underscore, followed by letters, numbers, or underscores');\n                                }\n\n                                fieldList.push(fieldMatch[1]);\n                            } else if ((fieldMatch = re.bracketAccess.exec(replacementField)) !== null) {\n                                if (!re.allowedNumericIndex.test(fieldMatch[1])) { // Ensure index is a number\n                                    throw new SyntaxError('[sprintf] Invalid array index in named argument key: must be a non-negative integer');\n                                }\n\n                                fieldList.push(fieldMatch[1]);\n                            } else {\n                                throw new SyntaxError('[sprintf] failed to parse named argument key');\n                            }\n                        }\n                    }\n                    else {\n                        throw new SyntaxError('[sprintf] failed to parse named argument key');\n                    }\n\n                    match[2] = fieldList;\n                }\n                // Handle positional arguments\n                else if (match[1]) { // Explicit positional placeholder\n                    positionalUsed = true;\n                }\n                else { // Implicit positional placeholder\n                    positionalUsed = true;\n                }\n\n                parseTree.push({\n                    placeholder: match[0],\n                    paramNo: match[1],\n                    keys: match[2],\n                    numeralPrefix: match[3],\n                    padChar: match[4],\n                    align: match[5],\n                    width: match[6],\n                    precision: match[7],\n                    type: match[8]\n                });\n            }\n            else {\n                throw new SyntaxError('[sprintf] unexpected placeholder');\n            }\n\n            _format = _format.substring(match[0].length);\n        }\n\n        const result = {\n            parseTree,\n            namedUsed,\n            positionalUsed\n        };\n\n        sprintfCache.set(format, result);\n\n        return result;\n    }\n\n    /**\n     * Similar to the Object.assign() static method objectAssign copies all enumerable\n     * own properties from one or more source objects to a target object. It returns\n     * the modified target object.\n     * @param {object} target The target object to apply the sources' properties to.\n     * @param {...object} sources The source object(s) from which to copy properties.\n     * @returns {object} The target object.\n     * @throws {TypeError} If target is null or undefined.\n     * @throws {TypeError} If no arguments are provided.\n     */\n    function objectAssign(target) {\n        if (arguments.length < 1) {\n            throw new TypeError('objectAssign expects at least one argument');\n        }\n\n        if (target === null || target === undefined) {\n            throw new TypeError('Cannot convert undefined or null to object');\n        }\n\n        for (let idx = 1; idx < arguments.length; idx++) {\n            const source = arguments[idx];\n\n            if (source === null || source === undefined) {\n                continue;\n            }\n\n            for (const key in source) {\n                if (Object.prototype.hasOwnProperty.call(source, key)) { // Only copy properties that are directly on the source object (not inherited)\n                    target[key] = source[key];\n                }\n            }\n        }\n\n        return target;\n    }\n\n    /**\n     * Similar to the `repeat()` method of String values, the `stringRepeat` function constructs\n     * and returns a new string containing the specified number of copies of the input string,\n     * concatenated together.\n     * @param {string} character The string to be repeated.\n     * @param {number} count An integer indicating the number of times to repeat the string.\n     * @returns {string} A new string containing the specified number of copies of the given character.\n     * @throws {RangeError} If count is negative.\n     */\n    function stringRepeat(character, count) {\n        if (count < 0) {\n            throw new RangeError('Repeat count must be non-negative');\n        }\n\n        if (count === 0) {\n            return '';\n        }\n\n        let result = '';\n\n        while (count) {\n            if (count & 1) { // Bitwise operations to handle count\n                result += character;\n            }\n\n            count >>= 1; // Bitwise right shift (equivalent to count = Math.floor(count / 2))\n\n            character += character;\n        }\n\n        return result;\n    }\n\n    /**\n     * Creates and returns a simple cache object.\n     * @returns {object} An object with methods for managing a cache.\n     */\n    function createCache() {\n        let cache = { __proto__: null };\n\n        return {\n            /**\n             * Retrieves a value from the cache.\n             * @param {string} key The key of the value to retrieve.\n             * @returns {*} The value associated with the key, or undefined if not found.\n             */\n            get: function (key) {\n                return cache[key];\n            },\n            /**\n             * Stores a value in the cache.\n             * @param {string} key The key to store the value under.\n             * @param {*} value The value to store.\n             * @returns {this} The cache object for chaining.\n             */\n            set: function (key, value) {\n                cache[key] = value;\n\n                return this;\n            },\n            /**\n             * Checks if a key exists in the cache.\n             * @param {string} key The key to check for.\n             * @returns {boolean} True if the key exists in the cache, false otherwise.\n             */\n            has: function (key) {\n                return key in cache;\n            },\n            /**\n             * Removes a key and its associated value from the cache.\n             * @param {string} key The key to remove.\n             */\n            delete: function (key) {\n                delete cache[key];\n            },\n            /**\n             * Clears all entries from the cache.\n             */\n            clear: function () {\n                cache = { __proto__: null };\n            }\n        };\n    }\n\n    sprintf.config = config;\n    vsprintf.config = config;\n\n    // Module export setup\n    const sprintfLib = {\n        sprintf: sprintf,\n        vsprintf: vsprintf,\n        config: config\n    };\n\n    // Browser global export\n    if (typeof window !== 'undefined') {\n        window.sprintf = sprintf;\n        window.vsprintf = vsprintf;\n\n        // AMD module definition\n        if (typeof define === 'function' && define.amd) {\n            define(() => sprintfLib);\n        }\n    }\n\n    // CommonJS export\n    if (typeof exports !== 'undefined') {\n        exports.sprintf = sprintf;\n        exports.vsprintf = vsprintf;\n    }\n\n    // Node.js module export\n    if (typeof module !== 'undefined' && module.exports) {\n        module.exports = sprintfLib;\n    }\n}();\n"]}