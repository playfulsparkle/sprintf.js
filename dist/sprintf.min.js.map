{"version":3,"sources":["sprintf.js"],"names":["re","notType","notPrimitive","number","numericArg","jsonObject","plainText","doublePercent","placeholder","namedKey","dotAccess","bracketAccess","numeralPrefix","allowedNamedKeyChars","allowedNumericIndex","sprintfCache","Map","sprintf","key","parseResult","format","has","get","let","_format","parseTree","namedUsed","positionalUsed","match","exec","push","SyntaxError","fieldList","replacementField","fieldMatch","test","substring","length","index","paramNo","keys","padChar","align","width","precision","type","result","set","argv","Array","from","arguments","slice","usesNamedArgs","cursor","treeLength","namedArgs","Object","create","output","filteredArgv","idx","isArray","assign","padCharacter","pad","arg","k","placeholderKey","Error","e","isNaN","TypeError","isPositive","parseInt","toString","String","fromCharCode","JSON","stringify","parseFloat","toExponential","toFixed","Number","toPrecision","prototype","call","toLowerCase","valueOf","toUpperCase","replace","charAt","padLength","repeat","vsprintf","apply","concat","sprintfLib","window","define","amd","exports","module"],"mappings":"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","file":"sprintf.min.js","sourcesContent":["/* global window, exports, define */\n\n!function () {\n    'use strict';\n\n    /**\n     * Regular expressions used for parsing format strings\n     * @namespace\n     */\n    const re = {\n        // Matches if type is NOT 'T' (type detection)\n        notType: /[^T]/,\n        // Matches if type is NOT 'v' (primitive value)\n        notPrimitive: /[^v]/,\n        // Matches numeric format specifiers\n        number: /[diefg]/,\n        // Matches numeric argument types requiring number validation\n        numericArg: /[bcdiefguxX]/,\n        // Matches JSON object specifier\n        jsonObject: /[j]/,\n        // Matches plain text between format specifiers\n        plainText: /^[^\\x25]+/,\n        // Matches double percent (escaped percent)\n        doublePercent: /^\\x25{2}/,\n        // Matches format placeholder components\n        placeholder: /^\\x25(?:([1-9]\\d*)\\$|\\(([^)]+)\\))?(\\+)?(0|'[^$])?(-)?(\\d+)?(?:\\.(\\d+))?([b-gijostTuvxX])/,\n        // Matches valid named argument keys\n        namedKey: /^([a-z_][a-z_\\d]*)/i,\n        // Matches dot notation in named arguments\n        dotAccess: /^\\.([a-z_][a-z_\\d]*)/i,\n        // Matches array index access in named arguments\n        bracketAccess: /^\\[(\\d+)\\]/,\n        // Matches numeric sign prefixes\n        numeralPrefix: /^[+-]/,\n        allowedNamedKeyChars: /^[a-zA-Z_][a-zA-Z0-9_]*$/,\n        allowedNumericIndex: /^\\d+$/\n    };\n\n    /**\n     * Cache for parsed format strings to improve performance\n     * @type {Map<string, {parseTree: Array<string|Placeholder>, namedUsed: boolean, positionalUsed: boolean}>}\n     */\n    const sprintfCache = new Map();\n\n    /**\n     * @typedef {Object} Placeholder\n     * @property {string} placeholder - The entire matched placeholder string\n     * @property {string} [paramNo] - Positional parameter number (1-based index)\n     * @property {Array<string>} [keys] - Named parameter access path\n     * @property {string} [numeralPrefix] - '+' sign for positive numbers\n     * @property {string} [padChar] - Padding character (e.g., '0' or space)\n     * @property {boolean} [align] - Left-align flag (true when '-' present)\n     * @property {string} [width] - Minimum field width\n     * @property {string} [precision] - Precision for numbers/strings\n     * @property {string} type - Conversion type character\n     */\n\n    /**\n     * Main formatting function similar to C's sprintf\n     * @param {string} key - Format string containing placeholders\n     * @param {...*} args - Values to format\n     * @returns {string} Formatted string\n     * @throws {Error} On invalid arguments or formatting errors\n     */\n    function sprintf(key) {\n        const parseResult = parse(key);\n        return format(parseResult.parseTree, Array.from(arguments).slice(1), parseResult.namedUsed);\n    }\n\n    /**\n     * Version of sprintf that accepts arguments as an array\n     * @param {string} format - Format string\n     * @param {Array} argv - Array of values to format\n     * @returns {string} Formatted string\n     */\n    function vsprintf(format, argv) {\n        return sprintf.apply(null, [format].concat(argv || []));\n    }\n\n    /**\n     * Core formatting engine that processes parsed format tree\n     * @param {Array<string|Placeholder>} parseTree - Result from parse()\n     * @param {Array} argv - Values to format\n     * @param {boolean} usesNamedArgs - Whether format uses named arguments\n     * @returns {string} Formatted string\n     * @throws {TypeError} On invalid numeric arguments\n     * @throws {Error} On missing named arguments\n     */\n    function format(parseTree, argv, usesNamedArgs) {\n        let cursor = 0;\n        const treeLength = parseTree.length;\n        const namedArgs = Object.create(null);\n        let output = '';\n\n        // Extract named arguments and filter positional arguments if named are used\n        const filteredArgv = [];\n\n        if (usesNamedArgs) {\n            for (let idx = 0; idx < argv.length; idx++) {\n                if (argv[idx] !== null && typeof argv[idx] === 'object' && !Array.isArray(argv[idx])) {\n                    Object.assign(namedArgs, argv[idx]);\n                } else {\n                    filteredArgv.push(argv[idx]);\n                }\n            }\n\n            // Use filteredArgv for positional parameters\n            argv = filteredArgv;\n        }\n\n        for (let idx = 0; idx < treeLength; idx++) {\n            const placeholder = parseTree[idx];\n\n            if (typeof placeholder === 'string') {\n                output += placeholder;\n\n                continue;\n            }\n\n            let arg;\n\n            // Get the argument value\n            if (placeholder.keys) { // keyword argument\n                arg = namedArgs;\n\n                for (let k = 0; k < placeholder.keys.length; k++) {\n                    const placeholderKey = placeholder.keys[k];\n\n                    if (arg === undefined || arg === null) {\n                        throw new Error(`[sprintf] Cannot access property \"${placeholderKey}\" of undefined value`);\n                    }\n\n                    arg = arg[placeholderKey];\n                }\n            } else if (placeholder.paramNo) { // Explicit positional argument\n                arg = argv[placeholder.paramNo - 1];\n            } else { // Implicit positional argument\n                arg = argv[cursor++];\n            }\n\n            // Handle function arguments for non-type/non-primitive specifiers\n            if (re.notType.test(placeholder.type) && re.notPrimitive.test(placeholder.type) && typeof arg === 'function') {\n                try {\n                    arg = arg();\n                } catch (e) {\n                    throw new Error('[sprintf] Failed to execute function argument');\n                }\n            }\n\n            // Validate numeric arguments for numeric placeholders\n            if (re.numericArg.test(placeholder.type) && (typeof arg !== 'number' && isNaN(arg))) {\n                throw new TypeError(`[sprintf] expecting number but found ${typeof arg}`);\n            }\n\n            let isPositive;\n            let numeralPrefix = '';\n\n            // Format according to type\n            if (re.number.test(placeholder.type)) {\n                isPositive = arg >= 0;\n            }\n\n            // Process argument based on format specifier\n            switch (placeholder.type) {\n                case 'b': // Binary\n                    arg = parseInt(arg, 10).toString(2);\n                    break;\n                case 'c': // Character\n                    arg = String.fromCharCode(parseInt(arg, 10));\n                    break;\n                case 'd': // Integer\n                case 'i':\n                    arg = parseInt(arg, 10);\n                    break;\n                case 'j': // JSON\n                    arg = JSON.stringify(arg, null, placeholder.width ? parseInt(placeholder.width) : 0);\n                    break;\n                case 'e': // Exponential notation\n                    arg = placeholder.precision ? parseFloat(arg).toExponential(placeholder.precision) : parseFloat(arg).toExponential();\n                    break;\n                case 'f': // Fixed-point\n                    arg = placeholder.precision ? parseFloat(arg).toFixed(placeholder.precision) : parseFloat(arg);\n                    break;\n                case 'g': // General format\n                    arg = placeholder.precision ? String(Number(arg.toPrecision(placeholder.precision))) : parseFloat(arg);\n                    break;\n                case 'o': // Octal\n                    arg = (parseInt(arg, 10) >>> 0).toString(8);\n                    break;\n                case 's': // String\n                    arg = String(arg);\n                    arg = (placeholder.precision ? arg.substring(0, placeholder.precision) : arg);\n                    break;\n                case 't': // Boolean\n                    arg = String(!!arg);\n                    arg = (placeholder.precision ? arg.substring(0, placeholder.precision) : arg);\n                    break;\n                case 'T': // Type detection\n                    arg = Object.prototype.toString.call(arg).slice(8, -1).toLowerCase();\n                    arg = (placeholder.precision ? arg.substring(0, placeholder.precision) : arg);\n                    break;\n                case 'u': // Unsigned integer\n                    arg = parseInt(arg, 10) >>> 0;\n                    break;\n                case 'v': // Primitive value\n                    arg = String(arg.valueOf());\n                    arg = (placeholder.precision ? arg.substring(0, placeholder.precision) : arg);\n                    break;\n                case 'x': // Hexadecimal (lowercase)\n                    arg = (parseInt(arg, 10) >>> 0).toString(16);\n                    break;\n                case 'X': // Hexadecimal (uppercase)\n                    arg = (parseInt(arg, 10) >>> 0).toString(16).toUpperCase();\n                    break;\n                default:\n                    throw new Error(`[sprintf] Unknown type: ${placeholder.type}`);\n            }\n\n            // Apply padding and alignment\n            if (re.jsonObject.test(placeholder.type)) {\n                output += arg;\n            } else {\n                // Handle numeric sign prefix\n                if (re.number.test(placeholder.type) && (!isPositive || placeholder.numeralPrefix)) {\n                    numeralPrefix = isPositive ? '+' : '-';\n                    arg = String(arg).replace(re.numeralPrefix, '');\n                }\n\n                const padCharacter = placeholder.padChar ? placeholder.padChar === '0' ? '0' : placeholder.padChar.charAt(1) : ' ';\n                const padLength = placeholder.width - (numeralPrefix + arg).length;\n                const pad = placeholder.width && padLength > 0 ? padCharacter.repeat(padLength) : '';\n\n                output += placeholder.align ? numeralPrefix + arg + pad : (padCharacter === '0' ? numeralPrefix + pad + arg : pad + numeralPrefix + arg);\n            }\n        }\n\n        return output;\n    }\n\n    /**\n     * Parses format string into executable tree structure\n     * @param {string} format - Format string to parse\n     * @returns {{parseTree: Array<string|Placeholder>, namedUsed: boolean, positionalUsed: boolean}}\n     * @throws {SyntaxError} On invalid format syntax\n     */\n    function parse(format) {\n        if (sprintfCache.has(format)) {\n            return sprintfCache.get(format);\n        }\n\n        let _format = format;\n        const parseTree = [];\n        let namedUsed = false;\n        let positionalUsed = false;\n\n        while (_format) {\n            let match;\n\n            // Match plain text between placeholders\n            if ((match = re.plainText.exec(_format)) !== null) {\n                parseTree.push(match[0]);\n            }\n            // Match escaped percent (%%)\n            else if ((match = re.doublePercent.exec(_format)) !== null) {\n                parseTree.push('%');\n            }\n            // Match complex placeholders\n            else if ((match = re.placeholder.exec(_format)) !== null) {\n                // Handle named arguments\n                if (match[2]) {\n                    namedUsed = true;\n                    const fieldList = [];\n                    let replacementField = match[2];\n                    let fieldMatch;\n\n                    if ((fieldMatch = re.namedKey.exec(replacementField)) !== null) {\n                        if (!re.allowedNamedKeyChars.test(fieldMatch[1])) {\n                            throw new SyntaxError('[sprintf] Invalid named argument key segment: must start with a letter or underscore, followed by letters, numbers, or underscores');\n                        }\n\n                        fieldList.push(fieldMatch[1]);\n\n                        while ((replacementField = replacementField.substring(fieldMatch[0].length)) !== '') {\n                            if ((fieldMatch = re.dotAccess.exec(replacementField)) !== null) {\n                                if (!re.allowedNamedKeyChars.test(fieldMatch[1])) {\n                                    throw new SyntaxError('[sprintf] Invalid named argument key segment after dot: must start with a letter or underscore, followed by letters, numbers, or underscores');\n                                }\n\n                                fieldList.push(fieldMatch[1]);\n                            } else if ((fieldMatch = re.bracketAccess.exec(replacementField)) !== null) {\n                                if (!re.allowedNumericIndex.test(index)) { // Ensure index is a number\n                                    throw new SyntaxError('[sprintf] Invalid array index in named argument key: must be a non-negative integer');\n                                }\n\n                                fieldList.push(fieldMatch[1]);\n                            } else {\n                                throw new SyntaxError('[sprintf] failed to parse named argument key');\n                            }\n                        }\n                    }\n                    else {\n                        throw new SyntaxError('[sprintf] failed to parse named argument key');\n                    }\n\n                    match[2] = fieldList;\n                }\n                // Handle positional arguments\n                else if (match[1]) { // Explicit positional placeholder\n                    positionalUsed = true;\n                }\n                else { // Implicit positional placeholder\n                    positionalUsed = true;\n                }\n\n                parseTree.push({\n                    placeholder: match[0],\n                    paramNo: match[1],\n                    keys: match[2],\n                    numeralPrefix: match[3],\n                    padChar: match[4],\n                    align: match[5],\n                    width: match[6],\n                    precision: match[7],\n                    type: match[8]\n                });\n            }\n            else {\n                throw new SyntaxError('[sprintf] unexpected placeholder');\n            }\n\n            _format = _format.substring(match[0].length);\n        }\n\n        const result = {\n            parseTree,\n            namedUsed,\n            positionalUsed\n        };\n\n        sprintfCache.set(format, result);\n\n        return result;\n    }\n\n    // Module export setup\n    const sprintfLib = {\n        sprintf: sprintf,\n        vsprintf: vsprintf\n    };\n\n    // Browser global export\n    if (typeof window !== 'undefined') {\n        // Safely expose to window without overwriting\n        window.sprintf = sprintf;\n        window.vsprintf = vsprintf;\n\n        // AMD module definition\n        if (typeof define === 'function' && define.amd) {\n            define(() => sprintfLib);\n        }\n    }\n\n    // CommonJS export\n    if (typeof exports !== 'undefined') {\n        exports.sprintf = sprintf;\n        exports.vsprintf = vsprintf;\n    }\n\n    // Node.js module export\n    if (typeof module !== 'undefined' && module.exports) {\n        module.exports = sprintfLib;\n    }\n}();\n"]}